<!DOCTYPE html>
<html>
  <head>
    <title>addeventhandlerHTML</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <style type="text/css">
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: "Segoe UI", Helvetica, Arial, Sans-Serif;
      }
    </style>
  </head>
  <body>
    <div id="printoutPanel"></div>

    <div id="myMap" style="width: 100vw; height: 100vh"></div>
    <style>
      .mapContainer {
          position:relative;
          width:800px;
          height:600px;
      }

      #map {
          position:relative;
          width:800px;
          height:600px;
      }

      .legend {
          position:absolute;
          top:5px;
          left:5px;
          width:256px;
          height:35px;
          font-family:Arial;
          font-size:12px;
          background-color:rgba(255, 255, 255, 0.8);
          border-radius:5px;
          padding:5px;
      }

      #legendCanvas {
          width:256px;
          height:15px;
      }

      .legend-max {
          float:right;
      }
  </style>
    <div class="legend">
      <canvas id="legendCanvas"></canvas>
      <span class="legend-min">0</span>
      <span class="legend-max">1182</span>
  </div>
    <script type="text/javascript">

function createLegend(maxValue) {
        var canvas = document.getElementById('legendCanvas');
        var ctx = canvas.getContext('2d');

        //Create a linear gradient for the legend. 
        var colorGradient = {
            "0.00": 'rgba(0,255,0,255)',    // Green
            "0.50": 'rgba(255,255,0,255)',  // Yellow
            "1.00": 'rgba(255,0,0,255)'     // Red
        };

        var grd = ctx.createLinearGradient(0, 0, 256, 0);
        for (var c in colorGradient) {
            grd.addColorStop(c, colorGradient[c]);
        }
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        //Store the pixel information from the legend.
        heatGradientData = ctx.getImageData(0, 0, canvas.width, 1);
    }

    function getLegendColor(value, maxValue) {
        value = (value > maxValue) ? maxValue : value;

        //Calculate the pixel data index from the ratio of value/maxValue.
        var idx = Math.round((value / maxValue) * 256) * 4 - 4;

        if (idx < 0) {
            idx = 0;
        }

        //Create an RGBA color from the pixel data at the calculated index.
        return 'rgba('+ heatGradientData.data[idx]+ ',' +
            heatGradientData.data[idx + 1] + ',' +
            heatGradientData.data[idx + 2] + ',' + '0.5)';
    }
      var building = {};

      function getData(url, headers) {
        return new Promise((resolve, reject) => {
          fetch(url, {
            mode: "cors",
            header: headers,
            method: "GET",
          })
            .then((response) => response.json())
            .then((data) => {
              resolve(data);
            })
            .catch((error) => {
              console.log("Error: \n");
              reject(error);
            });
        });
      }

      function postData(url, headers, data = {}) {
        return new Promise((resolve, reject) => {
          // console.log(JSON.stringify(data));
          fetch(url, {
            mode: "cors",
            header: headers,
            method: "POST",
            body: JSON.stringify(data)
          })
            .then((response) => response.json())
            .then((data) => {
              resolve(data);
            })
            .catch((error) => {
              console.log("Error: \n");
              console.log(error);
              reject(error);
            });
        });
      }

      function createPolygon(points, map) {
        var polyData = [];
        points.forEach((point) => {
          const [long, lat] = point;
          polyData.push(new Microsoft.Maps.Location(lat, long));
        });
        var polygon = new Microsoft.Maps.Polygon(polyData);
        polygon.setOptions({
          fillColor: "#96ef942b",
        });
        map.entities.push(polygon);
      }

      async function getBuildings(map) {
        const myHeaders = new Headers();
        let response = await getData("http://localhost:3000/api/buildings", {
          "Content-Type": "application/json",
        });
        const buildings = response.features;
        buildings.forEach((item) => {
          // response.forEach((item) => {
          if (item.geometry.type === "Polygon") {
            item.geometry.coordinates.forEach((coordinates) => {
              createPolygon(coordinates, map);
            });
          }
          // createPolygon(item.zone, map);
        });
      }

      // init();
      async function getZone(map) {
        const myHeaders = new Headers();
        let response = await getData("http://localhost:3000/api/bounds", {
          "Content-Type": "application/json",
        });
        
        response.forEach((zone) => {
          // response.forEach((item) => {
              createZone(map, zone)
              // createPolygon(coordinates, map);
            });
        
          // createPolygon(item.zone, map);
        
      }
      function createZone(map, zone) {
        console.log(zone.northwest_lat, zone.northwest_lon);
        console.log(new Microsoft.Maps.Location(zone.northwest_lat, zone.northwest_lon));
        var bounds = Microsoft.Maps.LocationRect.fromLocations(
          [new Microsoft.Maps.Location(zone.northwest_lat, zone.northwest_lon),
          new Microsoft.Maps.Location(zone.southeast_lat, zone.southeast_lon)]
        );
        Microsoft.Maps.loadModule('Microsoft.Maps.SpatialMath', function () {
          var polygon = Microsoft.Maps.SpatialMath.locationRectToPolygon(bounds);
          polygon.setOptions({fillColor: getLegendColor(zone.crimes, 1182)});
          // console.log(polygon);
          map.entities.push(polygon);
        })
        // console.log(boundsCoordinates);
        
        // boundsCoordinates = [bounds.getNorthwest().latitude, bounds.getNorthwest().longitude, bounds.getSoutheast().latitude, bounds.getSoutheast().longitude];
        // return boundsCoordinates;

      }

      // function createBox(x1, y1, x2, y2) {
      //   var bounds = Microsoft.Maps.LocationRect.fromLocations(
      //     new Microsoft.Maps.Location(x1, y1),
      //     new Microsoft.Maps.Location(x2, y2)
      //   );
      //   var boundsBorder = new Microsoft.Maps.Polyline(
      //     [
      //       bounds.getNorthwest(),
      //       new Microsoft.Maps.Location(
      //         bounds.getNorthwest().latitude,
      //         bounds.getSoutheast().longitude
      //       ),
      //       bounds.getSoutheast(),
      //       new Microsoft.Maps.Location(
      //         bounds.getSoutheast().latitude,
      //         bounds.getNorthwest().longitude
      //       ),
      //       bounds.getNorthwest(),
      //     ],
      //     { strokeColor: "blue", strokeThickness: 1 }
      //   );
      //   return boundsBorder;
      // }
      async function getPolygon(map) {
        let response = await getData("http://localhost:3000/api/polygons", {
          "Content-Type": "application/json",
        });
        response.forEach((item) => {
          // if (building.geometry.type === "Polygon") {
          //   building.geometry.coordinates.forEach((coordinates) => {
          //     createPolygon(coordinates, map);
          //   });
          // }
          const boundsBorder = createBox(item[0], item[1], item[2], item[3]);
          map.entities.push(boundsBorder);
        });
      }
      function createCirclePushpin(
        location,
        radius,
        fillColor,
        strokeColor,
        strokeWidth
      ) {
        if (strokeColor === void 0) {
          strokeColor = "";
        }
        if (strokeWidth === void 0) {
          strokeWidth = 0;
        }
        //Create an SVG string of a circle with the specified radius and color.
        var svg =
          '<svg xmlns="http://www.w3.org/2000/svg" width="' +
          2 * radius +
          '" height="' +
          2 * radius +
          '">\n        <circle cx="' +
          radius +
          '" cy="' +
          radius +
          '" r="' +
          (radius - strokeWidth) +
          '" stroke="' +
          strokeColor +
          '" stroke-width="' +
          strokeWidth +
          '" fill="' +
          fillColor +
          '"/></svg>';
        //Create a pushpin from the SVG and anchor it to the center of the circle.
        return new Microsoft.Maps.Pushpin(location, {
          icon: svg,
          anchor: new Microsoft.Maps.Point(radius, radius),
        });
      }
      async function getBLP(map) {
        let response = await getData("http://localhost:3000/api/blp", {
          "Content-Type": "application/json",
        });
        response = response.features;
        response.forEach((item) => {
          // if (building.geometry.type === "Polygon") {
          //   building.geometry.coordinates.forEach((coordinates) => {
          //     createPolygon(coordinates, map);
          //   });
          // }
          const [long, lat] = item.geometry.coordinates;
          const boundsBorder = createCirclePushpin(
            new Microsoft.Maps.Location(lat, long),
            3,
            "rgba(0, 0, 255, 0.5)"
          );
          map.entities.push(boundsBorder);
        });
      }
      async function getSearch(map) {
        let response = await getData("http://localhost:3000/api/search", {
          "Content-Type": "application/json",
        });
        response.forEach((item) => {
          // if (building.geometry.type === "Polygon") {
          //   building.geometry.coordinates.forEach((coordinates) => {
          //     createPolygon(coordinates, map);
          //   });
          // }
          if (item.JTYPE == "BLDG" && item.LAT && item.LON) {
            const boundsBorder = createCirclePushpin(
              new Microsoft.Maps.Location(item.LAT, item.LON),
              3,
              "rgba(180, 73, 199, 0.4)"
            );
            map.entities.push(boundsBorder);
          }
        });
      }

      async function getBusStops(map) {
        let response = await getData("http://localhost:3000/api/bus_stops", {
          "Content-Type": "application/json",
        });
        response = response.features;
        response.forEach((item) => {
          // if (building.geometry.type === "Polygon") {
          //   building.geometry.coordinates.forEach((coordinates) => {
          //     createPolygon(coordinates, map);
          //   });
          // }
          const [long, lat] = item.geometry.coordinates;
          const boundsBorder = createCirclePushpin(
            new Microsoft.Maps.Location(lat, long),
            3,
            "rgba(0, 0, 0, 0.5)"
          );
          map.entities.push(boundsBorder);
        });
      }
      async function getCrimes(map) {
        let response = await getData("http://localhost:3000/api/crimes", {
          "Content-Type": "application/json",
        });
        // response = response.features;
        response.forEach((item) => {
          // if (building.geometry.type === "Polygon") {
          //   building.geometry.coordinates.forEach((coordinates) => {
          //     createPolygon(coordinates, map);
          //   });
          // }
          const [lat, long] = item;
          if (
            lat >= 29.528179 &&
            lat <= 29.752244 &&
            long >= -82.372585 &&
            long <= -82.339005
          ) {
            const boundsBorder = createCirclePushpin(
              new Microsoft.Maps.Location(lat, long),
              3,
              "rgba(226, 24, 24, 0.6)"
            );
            map.entities.push(boundsBorder);
          }
        });
      }

      async function saveCoordinates(boundsCoordinatesList) {
        let response = await postData("http://localhost:3000/api/save", {
          "Content-Type": "application/json",
        }, {boundsCoordinatesList: boundsCoordinatesList});
        console.log(response);
      }

      function GetMap() {
        createLegend(0.655127);
        // var bounds = Microsoft.Maps.LocationRect.fromLocations(
        //   new Microsoft.Maps.Location(29.652679, -82.37579),
        //   new Microsoft.Maps.Location(29.629072, -82.338049)
        // );
        var bounds = Microsoft.Maps.LocationRect.fromLocations(
          new Microsoft.Maps.Location(29.652244, -82.372585),
          new Microsoft.Maps.Location(29.628179, -82.339005)
        );

        var map = new Microsoft.Maps.Map(document.getElementById("myMap"), {
          maxBounds: bounds,
          // disableStreetside: true,
          center: new Microsoft.Maps.Location(29.652679, -82.37579),
          // customMapStyle: {
          //   elements: {
          //     area: { fillColor: "#b6e591" },
          //     water: { fillColor: "#75cff0" },
          //     tollRoad: { fillColor: "#a964f4", strokeColor: "#a964f4" },
          //     arterialRoad: { fillColor: "#ffffff", strokeColor: "#d7dae7" },
          //     road: { fillColor: "#ffa35a", strokeColor: "#ff9c4f" },
          //     street: { fillColor: "#ffffff", strokeColor: "#ffffff" },
          //     transit: { fillColor: "#000000" },
          //   },
          //   settings: {
          //     landColor: "#efe9e1",
          //   },
          // },
        });
        // getZone(map);
        // getPolygon(map);
        getSearch(map);
        getBLP(map);
        getBusStops(map);
        getCrimes(map);
        let pointMap = [];
        Microsoft.Maps.Events.addHandler(map, "click", function (e) {
          const location = e.location;
          pointMap.push([location.latitude, location.longitude]);
          var polyData = [];
          pointMap.forEach((element) => {
            [lat, long] = element;
            polyData.push(new Microsoft.Maps.Location(lat, long));
          });
          var polygon = new Microsoft.Maps.Polygon(polyData);
          map.entities.push(polygon);
          polygon.setOptions({
            fillColor: "transparent",
          });
          console.log(JSON.stringify(pointMap));
        });
        // }

        document.getElementById("printoutPanel").innerHTML = "View changed.";
        var boundsBorder = new Microsoft.Maps.Polyline(
          [
            bounds.getNorthwest(),
            new Microsoft.Maps.Location(
              bounds.getNorthwest().latitude,
              bounds.getSoutheast().longitude
            ),
            bounds.getSoutheast(),
            new Microsoft.Maps.Location(
              bounds.getSoutheast().latitude,
              bounds.getNorthwest().longitude
            ),
            bounds.getNorthwest(),
          ],
          { strokeColor: "transparent", strokeThickness: 5 }
        );
        var point1 = map.tryLocationToPixel(
          bounds.getNorthwest(),
          Microsoft.Maps.PixelReference.control
        );

        var point2 = map.tryLocationToPixel(
          bounds.getSoutheast(),
          Microsoft.Maps.PixelReference.control
        );
        document.getElementById("printoutPanel").innerHTML +=
          "<b>Location to point1</b> <br>" +
          point1 +
          "<b>Location to point2</b> <br>" +
          point2;
        map.entities.push(boundsBorder);
        // boundsCoordinatesList = []
        // for (var x = point1.x; x <= point2.x; x += 16) {
        //   for (var y = point1.y; y <= point2.y; y += 16) {
        //     createBox(map, x, y);
        //   }
        // }
        // console.log(boundsCoordinatesList);
        // saveCoordinates(boundsCoordinatesList);
        getZone(map);
        // Binding the events
        Microsoft.Maps.Events.addHandler(map, "viewchange", function () {
          document.getElementById("printoutPanel").innerHTML =
            "View changing...";
        });
        Microsoft.Maps.Events.addHandler(map, "viewchangeend", function () {
          document.getElementById("printoutPanel").innerHTML = "View changed.";
        });
      }
      // function createBox(map, x, y) {
      //   var bounds = Microsoft.Maps.LocationRect.fromLocations(
      //     map.tryPixelToLocation(
      //       new Microsoft.Maps.Point(x, y),
      //       Microsoft.Maps.PixelReference.control
      //     ),
      //     map.tryPixelToLocation(
      //       new Microsoft.Maps.Point(x + 16, y + 16),
      //       Microsoft.Maps.PixelReference.control
      //     )
      //   );
      //   Microsoft.Maps.loadModule('Microsoft.Maps.SpatialMath', function () {
      //     var polygon = Microsoft.Maps.SpatialMath.locationRectToPolygon(bounds);
          
      //     map.entities.push(polygon);
      //   })
      //   // console.log(boundsCoordinates);
        
      //   // boundsCoordinates = [bounds.getNorthwest().latitude, bounds.getNorthwest().longitude, bounds.getSoutheast().latitude, bounds.getSoutheast().longitude];
      //   // return boundsCoordinates;

      // }
      
    </script>
    <script
      type="text/javascript"
      src="https://www.bing.com/api/maps/mapcontrol?callback=GetMap&key=AluujRQBFSr8aENSYJ9h4vR9yxCrOjUk5e-1mHGv5EXBMf4F7R_xkIpvmSmyghRg"
      async
      defer
    ></script>
  </body>
</html>
